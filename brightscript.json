{
	// ifAppInfo
	"ifAppInfo_GetID": {
		"prefix": "GetID() :: ifAppInfo",
		"body": "GetID()",
		"description": "(as String) Returns the app's channel ID, e.g. \"12345\" or \"dev\""
	},
	"ifAppInfo_IsDev": {
		"prefix": "IsDev() :: ifAppInfo",
		"body": "IsDev()",
		"description": "(as Boolean) Returns true if the application is side-loaded, i.e. the channel ID is \"dev\""
	},
	"ifAppInfo_GetVersion": {
		"prefix": "GetVersion() :: ifAppInfo",
		"body": "GetVersion()",
		"description": "(as String) Returns the conglomerate version number from the manifest, e.g. \"1.2.3\", as formatted major_version + minor_version + build_version."
	},
	"ifAppInfo_GetTitle": {
		"prefix": "GetTitle() :: ifAppInfo",
		"body": "GetTitle()",
		"description": "(as String) Returns the title value from the manifest."
	},
	"ifAppInfo_GetSubtitle": {
		"prefix": "GetSubtitle() :: ifAppInfo",
		"body": "GetSubtitle()",
		"description": "(as String) Returns the subtitle value from the manifest."
	},
	"ifAppInfo_GetDevID": {
		"prefix": "GetDevID() :: ifAppInfo",
		"body": "GetDevID()",
		"description": "(as String) Returns the app's developer ID, or the keyed developer ID, if the application is side-loaded."
	},
	"ifAppInfo_GetValue": {
		"prefix": "GetValue() :: ifAppInfo",
		"body": "GetValue(${1:key as String})",
		"description": "(as String) Returns the named manifest value, or an empty string if the entry is does not exist."
	},

	//ifAppManager
	"ifAppManager_SetTheme": {
		"prefix": "SetTheme() :: ifAppManager",
		"body": "SetTheme(${1:attributeArray as Object})",
		"description": "(as Void) Set a group of theme attributes for the application. The attributeArray is an roAssociativeArray of attribute/value pairs. The program may create the roAssociativeArray at runtime or read it from an XML file using the roXMLElement object. Existing values for attributes will be overwritten by the values provided. Any values set by a previous SetTheme or SetThemeAttribute call, but not included in the array currently provided by with the subsequent call will remain unchanged.  See roAppManager the list of valid attributes."
	},
	"ifAppManager_SetThemeAttribute": {
		"prefix": "SetThemeAttribute() :: ifAppManager",
		"body": "SetThemeAttribute(${1:attributeName as String}, ${2:attributeValue as String})",
		"description": "(as Void) Set an individual theme attribute for the application. The attributeName is the name of one of the settable theme attributes and the value is the desired setting. This value will override the default value for that attribute or modify the value provided by a previous SetTheme or SetThemeAttribute call to the new value provided. If the attributeName is not valid, no action is performed."
	},
	"ifAppManager_ClearThemeAttribute": {
		"prefix": "ClearThemeAttribute() :: ifAppManager",
		"body": "ClearThemeAttribute(${1:attributeName as String})",
		"description": "(as Void) Clears a previously set attribute and reverts to its default value."
	},
	"ifAppManager_GetUptime": {
		"prefix": "GetUptime() :: ifAppManager",
		"body": "GetUptime()",
		"description": "(as Object) Returns an roTimespan object which is \"marked\" when the user clicked on the application button on the home screen. Calling TotalMilliseconds() on the returned roTimespan object returns the total number of milliseconds since the application started."
	},
	"ifAppManager_GetScreensaverTimeout": {
		"prefix": "GetScreensaverTimeout() :: ifAppManager",
		"body": "GetScreensaverTimeout()",
		"description": "(as Integer) Returns the user's screensaver wait time setting in number of minutes, or zero if the screensaver is disabled."
	},
	"ifAppManager_UpdateLastKeyPressTime": {
		"prefix": "UpdateLastKeyPressTime() :: ifAppManager",
		"body": "UpdateLastKeyPressTime()",
		"description": "(as Void) UpdateLastKeyPressTime can be called to simulate user activity. This resets the idle timer that is used to count down to screensaver activation, so if a screensaver is not already displayed it will reset the timer and defer the activation. This should only be used when the user has specifically initiated a playback mode in your app, in which case you can call UpdateLastKeyPressTime periodically, such as when advancing the slideshow image."
	},
	"ifAppManager_SetUserSignedIn": {
		"prefix": "SetUserSignedIn() :: ifAppManager",
		"body": "SetUserSignedIn(${1:signedIn as Boolean})",
		"description": "(as Void) This method allows a channel to tell Roku when the user is signed in or signed out of the channel. If the channel is removed, then the firmware will call SetUserSignedIn(false) on the channel's behalf. This method accepts the signedIn parameter, which if set to true indicates the user is signed in, and if set to false, indicates the user is signed out."
	},
	"ifAppManager_SetAutomaticAudioGuideEnabled": {
		"prefix": "SetAutomaticAudioGuideEnabled() :: ifAppManager",
		"body": "SetAutomaticAudioGuideEnabled(${1:enabled as Boolean})",
		"description": "(as Void) Enables or disables automatic Audio Guide and override any manifest setting. This is useful for channels that want to temporarily turn off automatic Audio Guide for specific screens."
	},
	"ifAppManager_IsAppInstalled": {
		"prefix": "IsAppInstalled() :: ifAppManager",
		"body": "IsAppInstalled(${1:channelID as String}, ${2:version as String})",
		"description": "(as Boolean) This method returns true if a channel with the specified channelID and the minimum version required is installed. Version field could be an empty string to avoid a version check. This is useful for developers who want to cross-promote their apps. For example, if a developer writes a game A and an app B, in game A they would want to know if the user has app B installed so they know whether to advertise app B in game A to promote the app. If it is already installed, the developer would not need to advertise app B."
	},

	//ifArray
	"ifArray_Peek": {
		"prefix": "Peek() :: ifArray",
		"body": "Peek()",
		"description": "(as Dynamic) Returns the last (highest index) array entry without removing it.  If the array is empty, returns invalid."
	},
	"ifArray_Pop": {
		"prefix": "Pop() :: ifArray",
		"body": "Pop()",
		"description": "(as Dynamic) Returns the last (highest index) array entry and removes it from the array.  If the array is empty, returns invalid and does not change the array."
	},
	"ifArray_Push": {
		"prefix": "Push() :: ifArray",
		"body": "Push(${1:tvalue as Dynamic})",
		"description": "(as Void) Adds tvalue as the new highest index entry in the array (adds to the end of the array)."
	},
	"ifArray_Shift": {
		"prefix": "Shift() :: ifArray",
		"body": "Shift()",
		"description": "(as Dynamic) Removes the index zero entry from the array and shifts every other entry down one to fill the hole. Returns the removed entry. This is like a Pop from the start of the array instead of the end."
	},
	"ifArray_Unshift": {
		"prefix": "Unshift() :: ifArray",
		"body": "Unshift(${1:tvalue as Dynamic})",
		"description": "(as Void) Adds a new index zero to the array and shifts every other entry up one to accommodate. This is like a Push to the start of the array instead of the end."
	},
	"ifArray_Delete": {
		"prefix": "Delete() :: ifArray",
		"body": "Delete(${1:index as Integer})",
		"description": "(as Boolean) Deletes the indicated array entry, and shifts down all entries above to fill the hole. The array length is decreased by one.  If the entry was successfully deleted, returns true.  If index is out of range, returns false and does not change the array."
	},
	"ifArray_Count": {
		"prefix": "Count() :: ifArray",
		"body": "Count()",
		"description": "(as Integer) Returns the length of the array; that is, one more than the index of highest entry."
	},
	"ifArray_Clear": {
		"prefix": "Clear() :: ifArray",
		"body": "Clear()",
		"description": "(as Void) Deletes every entry in the array."
	},
	"ifArray_Append": {
		"prefix": "Append() :: ifArray",
		"body": "Append(${1:array as Object})",
		"description": "(as Void) Appends each entry of one roArray to another. If the passed Array contains \"holes\" (entries that were never set to a value), they are not appended."
	},

	//ifArrayGet
	"ifArrayGet_GetEntry": {
		"prefix": "GetEntry() :: ifArrayGet",
		"body": "GetEntry(${1:index as Integer})",
		"description": "(as Dynamic) Returns an Array entry of a given index. Entries start at zero. If an entry is fetched that has not been set, \"invalid\" is returned."
	},

	//ifArrayJoin
	"ifArrayJoin_Join": {
		"prefix": "Join() :: ifArrayJoin",
		"body": "Join(${1:separator as String})",
		"description": "(as String) Creates a string by joining all array elements together separated by the specified separator. All elements must be of type string, otherwise an empty string is returned."
	},

	//ifArraySet
	"ifArraySet_SetEntry": {
		"prefix": "SetEntry() :: ifArraySet",
		"body": "SetEntry(${1:index as Integer}, ${2:tvalue as Dynamic})",
		"description": "(as Void) Sets an entry at a given index to the passed value.  If index is beyond the bounds of the array, the array is expanded to accommodate it."
	},

	//ifArraySort
	"ifArraySort_Sort": {
		"prefix": "Sort() :: ifArraySort",
		"body": "Sort(${1:flags as String = \"\"})",
		"description": "(as Void) Performs a stable sort. Items are arbitrarily grouped by comparable type of number or string, and are sorted within the group with a logical comparison. If \"r\" is included in flags, a reverse sort is performed. If \"i\" is included in flags, a case-insensitive sort is performed. If invalid flags are specified, the sort is not performed."
	},
	"ifArraySort_SortBy": {
		"prefix": "SortBy() :: ifArraySort",
		"body": "SortBy(${1:fieldName as String}, ${2:flags as String = \"\"})",
		"description": "(as Void) Performs a stable sort of an array of associative arrays by value of a common field. Items are arbitrarily grouped by comparable value type of number or string, and are sorted within the group with a logical comparison. If \"r\" is included in flags, a reverse sort is performed. If \"i\" is included in flags, a case-insensitive sort is performed. If invalid flags are specified, the sort is not performed."
	},
	"ifArraySort_Reverse": {
		"prefix": "Reverse() :: ifArraySort",
		"body": "Reverse()",
		"description": "(as Void) Reverses the order of elements in an array."
	},

	//ifAssociativeArray
	"ifAssociativeArray_AddReplace": {
		"prefix": "AddReplace() :: ifAssociativeArray",
		"body": "AddReplace(${1:key as String}, ${2:value as Dynamic})",
		"description": "(as Void) Add a new entry to the array associating the supplied value with the supplied key string. Only one value may be associated with a key.  If the key is already associated with a value, the existing value is discarded."
	},
    "ifAssociativeArray_Lookup": {
		"prefix": "Lookup() :: ifAssociativeArray",
		"body": "Lookup(${1:key as String})",
		"description": "(as Dynamic) Return the value in the array associated with the specified key. If there is no value associated with the key then type \"invalid\" is returned.  Key comparison is case-insensitive, unless SetModeCaseSensitive() has been called."
	},
    "ifAssociativeArray_DoesExist": {
		"prefix": "DoesExist() :: ifAssociativeArray",
		"body": "DoesExist(${1:key as String})",
		"description": "(as Boolean) Look for an entry in the array associated with the specified key. If there is no associated object then false is returned. If there is such an object then true is returned."
	},
    "ifAssociativeArray_Delete": {
		"prefix": "Delete() :: ifAssociativeArray",
		"body": "Delete(${1:key as String})",
		"description": "(as Boolean) Look for an entry in the array associated with the specified key. If there is such an value then it is deleted and true is returned. If not then false is returned."
	},
    "ifAssociativeArray_Clear": {
		"prefix": "Clear() :: ifAssociativeArray",
		"body": "Clear()",
		"description": "(as Void) Remove all key/values from the associative array."
	},
	"ifAssociativeArray_Keys": {
		"prefix": "Keys() :: ifAssociativeArray",
		"body": "Keys()",
		"description": "(as Object) Returns an array containing the associative array keys in lexicographical order."
	},
	"ifAssociativeArray_Items": {
		"prefix": "Items() :: ifAssociativeArray",
		"body": "Items()",
		"description": "(as Object) Returns an array containing the associative array key/value pairs in lexicographical order of key. Each item is in the returned array is an associative array with 'key' and 'value' fields."
	},
    "ifAssociativeArray_SetModeCaseSensitive": {
		"prefix": "SetModeCaseSensitive() :: ifAssociativeArray",
		"body": "SetModeCaseSensitive()",
		"description": "(as Void) Associative Array lookups are case insensitive by default. This call makes all subsequent actions case sensitive."
	},
    "ifAssociativeArray_LookupCI": {
		"prefix": "LookupCI() :: ifAssociativeArray",
		"body": "LookupCI(${1:key as String})",
		"description": "(as Dynamic) Same as \"Lookup\" except key comparison is always case insensitive, regardless of case mode."
	},
    "ifAssociativeArray_Append": {
		"prefix": "Append() :: ifAssociativeArray",
		"body": "Append(${1:aa as Object})",
		"description": "(as Object) Append an AssociativeArray to this one.  If any key in aa is already associated with a value in this AssociativeArray, the current value is discarded and is replaced with the value in aa."
	},
    "ifAssociativeArray_Count": {
		"prefix": "Count() :: ifAssociativeArray",
		"body": "Count()",
		"description": "(as Integer) Returns the number of keys in the associative array."
	},

	//ifAudioGuide
	"ifAudioGuide_Say": {
		"prefix": "Say() :: ifAudioGuide",
		"body": "Say(${1:text as String}, ${2:flushSpeech as Boolean}, ${3:dontRepeat as Boolean})",
		"description": "(as Integer) Speaks the specified text string. This method does nothing if Audio Guide is currently disabled. This method returns an ID for the spoken string to notify observer callbacks about a specific spoken string. This ID can be used with roTextToSpeechEvent."
	},
	"ifAudioGuide_Flush": {
		"prefix": "Flush() :: ifAudioGuide",
		"body": "Flush()",
		"description": "(as Void) Interrupts and stops any current text to speech spoken string, to be used when the application does not want the text to speech to continue. Note that this call is equivalent to roTextToSpeech.Flush(), and stops speech started using both roAudioGuide.Say() and roTextToSpeech.Say()."
	},
	"ifAudioGuide_Silence": {
		"prefix": "Silence() :: ifAudioGuide",
		"body": "Silence(${1:duration as Integer})",
		"description": "(as Integer) If Audio Guide is enabled, causes text to speech to continue to suppress any application background sound for the amount of time specified by duration (in milliseconds). This can be used to add clarity for longer spoken text that may have pauses that might otherwise allow application background sound to be heard. This method does nothing if Audio Guide is currently disabled."
	},

	//ifAudioMetadata
	"ifAudioMetadata_SetUrl": {
		"prefix": "SetUrl() :: ifAudioMetadata",
		"body": "SetUrl(${1:url as String})",
		"description": "(as Void) Sets the URL to the audio file. Only file URLs are initially supported."
	},
    "ifAudioMetadatad_GetTags": {
		"prefix": "GetTags() :: ifAudioMetadata",
		"body": "GetTags()",
		"description": "(as Object) Returns an associative array that contains a simple set of tags that are common to most audio formats."
	},
    "ifAudioMetadata_GetAudioProperties": {
		"prefix": "GetAudioProperties() :: ifAudioMetadata",
		"body": "GetAudioProperties()",
		"description": "(as Object) Returns an associative array with a simple set of audio properties. These are values which may involve reading a larger portion of the file and thus may take longer to retrieve than the tags."
	},
    "ifAudioMetadata_GetCoverArt": {
		"prefix": "GetCoverArt() :: ifAudioMetadata",
		"body": "GetCoverArt()",
		"description": "(as Object) Returns the cover art if available. Returns an associative array with two entries: \"bytes\" and \"type\". \"bytes\" is an roByteArray containing the image data. \"type\" specifies the mime-type of the image which is almost always either \"image/jpeg\" or \"image/png\".  Looks for the picture designated as the cover art if there is more than one picture in the file. If there is no FrontCover picture then the first picture is used."
	},

	//ifAudioPlayer
	"ifAudioPlayer_SetContentList": {
		"prefix": "SetContentList() :: ifAudioPlayer",
		"body": "SetContentList(${1:contentList as Object})",
		"description": "(as Void) Set the content list to be played by the Audio Player. The caller passes an Array of AssociativeArrays (Content Meta-Data objects) representing the information for each stream to be played. See Content Meta-Data for details on the attributes for each element in the array."
	},
    "ifAudioPlayer_AddContent": {
		"prefix": "AddContent() :: ifAudioMetadata",
		"body": "AddContent(${1:contentItem as Object})",
		"description": "(as Void) Add a new ContentMetaData item to the content list for the Audio Player. The new item is added to the end of the content list."
	},
    "ifAudioPlayer_ClearContent": {
		"prefix": "ClearContent() :: ifAudioMetadata",
		"body": "ClearContent()",
		"description": "(as Void) Clear the content list."
	},
    "ifAudioPlayer_Play": {
		"prefix": "Play() :: ifAudioMetadata",
		"body": "Play()",
		"description": "(as Boolean) Put the Audio Player into play mode starting at the current item in the Content List. This will stop any currently playing content."
	},
    "ifAudioPlayer_Stop": {
		"prefix": "Stop() :: ifAudioMetadata",
		"body": "Stop()",
		"description": "(as Boolean) Stop Audio Player from playing or pausing and cleanup."
	},
    "ifAudioPlayer_Pause": {
		"prefix": "Pause() :: ifAudioMetadata",
		"body": "Pause()",
		"description": "(as Boolean) Put Audio Player into pause mode.  It is an error to Pause if player is not in play mode."
	},
    "ifAudioPlayer_Resume": {
		"prefix": "Resume() :: ifAudioMetadata",
		"body": "Resume()",
		"description": "(as Boolean) Put Audio Player into play mode starting from the pause point.  It is an error to Resume if the player is not in pause mode."
	},
    "ifAudioPlayer_SetLoop": {
		"prefix": "SetLoop() :: ifAudioMetadata",
		"body": "SetLoop(${1:enable as Boolean})",
		"description": "(as Void) Enable/disable the automatic replaying of the Content List.  When enabled, after playing the last item in the content list, the player begins playing the first item.  When disabled, after playing the last item in the content list, the player stops."
	},
    "ifAudioPlayer_SetNext": {
		"prefix": "SetNext() :: ifAudioMetadata",
		"body": "SetNext(${1:item as Integer})",
		"description": "(as Void) Set what the next item to be played within the Content List should be.  item is the zero-based index of the item in the content list.  This item will be played after the currently playing item finishes."
	},
    "ifAudioPlayer_Seek": {
		"prefix": "Seek() :: ifAudioMetadata",
		"body": "Seek(${1:offsetMs as Integer})",
		"description": "(as Boolean) Set the start point of playback for the current item to offsetMs milliseconds. If the item is currently playing, playback will be interrupted and will restart at the specified offset.  If the item is not currently playing, playback will begin at the specified offset when Play() is called."
	},
    "ifAudioPlayer_SetTimeMetaData": {
		"prefix": "SetTimeMetaDataForKeys() :: ifAudioMetadata",
		"body": "SetTimeMetaDataForKeys(${1:keys[] as Dynamic})",
		"description": "(as Void) This method is called to specify the timedMetaData keys that the BrightScript channel is interested in receiving from the timedMetaData event.  If the keys array is empty, all the timed metadata associated with the current stream is sent with the isTimedMetaData event.  If the keys array is invalid, then do not return any keys to the BrightScript channel.  Any keys not specified with this method are deleted by the firmware and never returned to the BrightScript application."
	}

}
