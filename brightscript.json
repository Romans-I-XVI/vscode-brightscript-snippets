{
	// ifAppInfo
	"ifAppInfo_GetID": {
		"prefix": "GetID() :: ifAppInfo",
		"body": "GetID()",
		"description": "(as String) Returns the app's channel ID, e.g. \"12345\" or \"dev\""
	},
	"ifAppInfo_IsDev": {
		"prefix": "IsDev() :: ifAppInfo",
		"body": "IsDev()",
		"description": "(as Boolean) Returns true if the application is side-loaded, i.e. the channel ID is \"dev\""
	},
	"ifAppInfo_GetVersion": {
		"prefix": "GetVersion() :: ifAppInfo",
		"body": "GetVersion()",
		"description": "(as String) Returns the conglomerate version number from the manifest, e.g. \"1.2.3\", as formatted major_version + minor_version + build_version."
	},
	"ifAppInfo_GetTitle": {
		"prefix": "GetTitle() :: ifAppInfo",
		"body": "GetTitle()",
		"description": "(as String) Returns the title value from the manifest."
	},
	"ifAppInfo_GetSubtitle": {
		"prefix": "GetSubtitle() :: ifAppInfo",
		"body": "GetSubtitle()",
		"description": "(as String) Returns the subtitle value from the manifest."
	},
	"ifAppInfo_GetDevID": {
		"prefix": "GetDevID() :: ifAppInfo",
		"body": "GetDevID()",
		"description": "(as String) Returns the app's developer ID, or the keyed developer ID, if the application is side-loaded."
	},
	"ifAppInfo_GetValue": {
		"prefix": "GetValue() :: ifAppInfo",
		"body": "GetValue(${1:key as String})",
		"description": "(as String) Returns the named manifest value, or an empty string if the entry is does not exist."
	},

	//ifAppManager
	"ifAppManager_SetTheme": {
		"prefix": "SetTheme() :: ifAppManager",
		"body": "SetTheme(${1:attributeArray as Object})",
		"description": "(as Void) Set a group of theme attributes for the application. The attributeArray is an roAssociativeArray of attribute/value pairs. The program may create the roAssociativeArray at runtime or read it from an XML file using the roXMLElement object. Existing values for attributes will be overwritten by the values provided. Any values set by a previous SetTheme or SetThemeAttribute call, but not included in the array currently provided by with the subsequent call will remain unchanged.  See roAppManager the list of valid attributes."
	},
	"ifAppManager_SetThemeAttribute": {
		"prefix": "SetThemeAttribute() :: ifAppManager",
		"body": "SetThemeAttribute(${1:attributeName as String}, ${2:attributeValue as String})",
		"description": "(as Void) Set an individual theme attribute for the application. The attributeName is the name of one of the settable theme attributes and the value is the desired setting. This value will override the default value for that attribute or modify the value provided by a previous SetTheme or SetThemeAttribute call to the new value provided. If the attributeName is not valid, no action is performed."
	},
	"ifAppManager_ClearThemeAttribute": {
		"prefix": "ClearThemeAttribute() :: ifAppManager",
		"body": "ClearThemeAttribute(${1:attributeName as String})",
		"description": "(as Void) Clears a previously set attribute and reverts to its default value."
	},
	"ifAppManager_GetUptime": {
		"prefix": "GetUptime() :: ifAppManager",
		"body": "GetUptime()",
		"description": "(as Object) Returns an roTimespan object which is \"marked\" when the user clicked on the application button on the home screen. Calling TotalMilliseconds() on the returned roTimespan object returns the total number of milliseconds since the application started."
	},
	"ifAppManager_GetScreensaverTimeout": {
		"prefix": "GetScreensaverTimeout() :: ifAppManager",
		"body": "GetScreensaverTimeout()",
		"description": "(as Integer) Returns the user's screensaver wait time setting in number of minutes, or zero if the screensaver is disabled."
	},
	"ifAppManager_UpdateLastKeyPressTime": {
		"prefix": "UpdateLastKeyPressTime() :: ifAppManager",
		"body": "UpdateLastKeyPressTime()",
		"description": "(as Void) UpdateLastKeyPressTime can be called to simulate user activity. This resets the idle timer that is used to count down to screensaver activation, so if a screensaver is not already displayed it will reset the timer and defer the activation. This should only be used when the user has specifically initiated a playback mode in your app, in which case you can call UpdateLastKeyPressTime periodically, such as when advancing the slideshow image."
	},
	"ifAppManager_SetUserSignedIn": {
		"prefix": "SetUserSignedIn() :: ifAppManager",
		"body": "SetUserSignedIn(${1:signedIn as Boolean})",
		"description": "(as Void) This method allows a channel to tell Roku when the user is signed in or signed out of the channel. If the channel is removed, then the firmware will call SetUserSignedIn(false) on the channel's behalf. This method accepts the signedIn parameter, which if set to true indicates the user is signed in, and if set to false, indicates the user is signed out."
	},
	"ifAppManager_SetAutomaticAudioGuideEnabled": {
		"prefix": "SetAutomaticAudioGuideEnabled() :: ifAppManager",
		"body": "SetAutomaticAudioGuideEnabled(${1:enabled as Boolean})",
		"description": "(as Void) Enables or disables automatic Audio Guide and override any manifest setting. This is useful for channels that want to temporarily turn off automatic Audio Guide for specific screens."
	},
	"ifAppManager_IsAppInstalled": {
		"prefix": "IsAppInstalled() :: ifAppManager",
		"body": "IsAppInstalled(${1:channelID as String}, ${2:version as String})",
		"description": "(as Boolean) This method returns true if a channel with the specified channelID and the minimum version required is installed. Version field could be an empty string to avoid a version check. This is useful for developers who want to cross-promote their apps. For example, if a developer writes a game A and an app B, in game A they would want to know if the user has app B installed so they know whether to advertise app B in game A to promote the app. If it is already installed, the developer would not need to advertise app B."
	},

	//ifArray
	"ifArray_Peek": {
		"prefix": "Peek() :: ifArray",
		"body": "Peek()",
		"description": "(as Dynamic) Returns the last (highest index) array entry without removing it.  If the array is empty, returns invalid."
	},
	"ifArray_Pop": {
		"prefix": "Pop() :: ifArray",
		"body": "Pop()",
		"description": "(as Dynamic) Returns the last (highest index) array entry and removes it from the array.  If the array is empty, returns invalid and does not change the array."
	},
	"ifArray_Push": {
		"prefix": "Push() :: ifArray",
		"body": "Push(${1:tvalue as Dynamic})",
		"description": "(as Void) Adds tvalue as the new highest index entry in the array (adds to the end of the array)."
	},
	"ifArray_Shift": {
		"prefix": "Shift() :: ifArray",
		"body": "Shift()",
		"description": "(as Dynamic) Removes the index zero entry from the array and shifts every other entry down one to fill the hole. Returns the removed entry. This is like a Pop from the start of the array instead of the end."
	},
	"ifArray_Unshift": {
		"prefix": "Unshift() :: ifArray",
		"body": "Unshift(${1:tvalue as Dynamic})",
		"description": "(as Void) Adds a new index zero to the array and shifts every other entry up one to accommodate. This is like a Push to the start of the array instead of the end."
	},
	"ifArray_Delete": {
		"prefix": "Delete() :: ifArray",
		"body": "Delete(${1:index as Integer})",
		"description": "(as Boolean) Deletes the indicated array entry, and shifts down all entries above to fill the hole. The array length is decreased by one.  If the entry was successfully deleted, returns true.  If index is out of range, returns false and does not change the array."
	},
	"ifArray_Count": {
		"prefix": "Count() :: ifArray",
		"body": "Count()",
		"description": "(as Integer) Returns the length of the array; that is, one more than the index of highest entry."
	},
	"ifArray_Clear": {
		"prefix": "Clear() :: ifArray",
		"body": "Clear()",
		"description": "(as Void) Deletes every entry in the array."
	},
	"ifArray_Append": {
		"prefix": "Append() :: ifArray",
		"body": "Append(${1:array as Object})",
		"description": "(as Void) Appends each entry of one roArray to another. If the passed Array contains \"holes\" (entries that were never set to a value), they are not appended."
	},

	//ifArrayGet
	"ifArrayGet_GetEntry": {
		"prefix": "GetEntry() :: ifArrayGet",
		"body": "GetEntry(${1:index as Integer})",
		"description": "(as Dynamic) Returns an Array entry of a given index. Entries start at zero. If an entry is fetched that has not been set, \"invalid\" is returned."
	},

	//ifArrayJoin
	"ifArrayJoin_Join": {
		"prefix": "Join() :: ifArrayJoin",
		"body": "Join(${1:separator as String})",
		"description": "(as String) Creates a string by joining all array elements together separated by the specified separator. All elements must be of type string, otherwise an empty string is returned."
	},

	//ifArraySet
	"ifArraySet_SetEntry": {
		"prefix": "SetEntry() :: ifArraySet",
		"body": "SetEntry(${1:index as Integer}, ${2:tvalue as Dynamic})",
		"description": "(as Void) Sets an entry at a given index to the passed value.  If index is beyond the bounds of the array, the array is expanded to accommodate it."
	},

	//ifArraySort
	"ifArraySort_Sort": {
		"prefix": "Sort() :: ifArraySort",
		"body": "Sort(${1:flags as String = \"\"})",
		"description": "(as Void) Performs a stable sort. Items are arbitrarily grouped by comparable type of number or string, and are sorted within the group with a logical comparison. If \"r\" is included in flags, a reverse sort is performed. If \"i\" is included in flags, a case-insensitive sort is performed. If invalid flags are specified, the sort is not performed."
	},
	"ifArraySort_SortBy": {
		"prefix": "SortBy() :: ifArraySort",
		"body": "SortBy(${1:fieldName as String}, ${2:flags as String = \"\"})",
		"description": "(as Void) Performs a stable sort of an array of associative arrays by value of a common field. Items are arbitrarily grouped by comparable value type of number or string, and are sorted within the group with a logical comparison. If \"r\" is included in flags, a reverse sort is performed. If \"i\" is included in flags, a case-insensitive sort is performed. If invalid flags are specified, the sort is not performed."
	},
	"ifArraySort_Reverse": {
		"prefix": "Reverse() :: ifArraySort",
		"body": "Reverse()",
		"description": "(as Void) Reverses the order of elements in an array."
	},

	//ifAssociativeArray
	"ifAssociativeArray_AddReplace": {
		"prefix": "AddReplace() :: ifAssociativeArray",
		"body": "AddReplace(${1:key as String}, ${2:value as Dynamic})",
		"description": "(as Void) Add a new entry to the array associating the supplied value with the supplied key string. Only one value may be associated with a key.  If the key is already associated with a value, the existing value is discarded."
	},
	"ifAssociativeArray_Lookup": {
		"prefix": "Lookup() :: ifAssociativeArray",
		"body": "Lookup(${1:key as String})",
		"description": "(as Dynamic) Return the value in the array associated with the specified key. If there is no value associated with the key then type \"invalid\" is returned.  Key comparison is case-insensitive, unless SetModeCaseSensitive() has been called."
	},
	"ifAssociativeArray_DoesExist": {
		"prefix": "DoesExist() :: ifAssociativeArray",
		"body": "DoesExist(${1:key as String})",
		"description": "(as Boolean) Look for an entry in the array associated with the specified key. If there is no associated object then false is returned. If there is such an object then true is returned."
	},
	"ifAssociativeArray_Delete": {
		"prefix": "Delete() :: ifAssociativeArray",
		"body": "Delete(${1:key as String})",
		"description": "(as Boolean) Look for an entry in the array associated with the specified key. If there is such an value then it is deleted and true is returned. If not then false is returned."
	},
	"ifAssociativeArray_Clear": {
		"prefix": "Clear() :: ifAssociativeArray",
		"body": "Clear()",
		"description": "(as Void) Remove all key/values from the associative array."
	},
	"ifAssociativeArray_Keys": {
		"prefix": "Keys() :: ifAssociativeArray",
		"body": "Keys()",
		"description": "(as Object) Returns an array containing the associative array keys in lexicographical order."
	},
	"ifAssociativeArray_Items": {
		"prefix": "Items() :: ifAssociativeArray",
		"body": "Items()",
		"description": "(as Object) Returns an array containing the associative array key/value pairs in lexicographical order of key. Each item is in the returned array is an associative array with 'key' and 'value' fields."
	},
	"ifAssociativeArray_SetModeCaseSensitive": {
		"prefix": "SetModeCaseSensitive() :: ifAssociativeArray",
		"body": "SetModeCaseSensitive()",
		"description": "(as Void) Associative Array lookups are case insensitive by default. This call makes all subsequent actions case sensitive."
	},
	"ifAssociativeArray_LookupCI": {
		"prefix": "LookupCI() :: ifAssociativeArray",
		"body": "LookupCI(${1:key as String})",
		"description": "(as Dynamic) Same as \"Lookup\" except key comparison is always case insensitive, regardless of case mode."
	},
	"ifAssociativeArray_Append": {
		"prefix": "Append() :: ifAssociativeArray",
		"body": "Append(${1:aa as Object})",
		"description": "(as Object) Append an AssociativeArray to this one.  If any key in aa is already associated with a value in this AssociativeArray, the current value is discarded and is replaced with the value in aa."
	},
	"ifAssociativeArray_Count": {
		"prefix": "Count() :: ifAssociativeArray",
		"body": "Count()",
		"description": "(as Integer) Returns the number of keys in the associative array."
	},

	//ifAudioGuide
	"ifAudioGuide_Say": {
		"prefix": "Say() :: ifAudioGuide",
		"body": "Say(${1:text as String}, ${2:flushSpeech as Boolean}, ${3:dontRepeat as Boolean})",
		"description": "(as Integer) Speaks the specified text string. This method does nothing if Audio Guide is currently disabled. This method returns an ID for the spoken string to notify observer callbacks about a specific spoken string. This ID can be used with roTextToSpeechEvent."
	},
	"ifAudioGuide_Flush": {
		"prefix": "Flush() :: ifAudioGuide",
		"body": "Flush()",
		"description": "(as Void) Interrupts and stops any current text to speech spoken string, to be used when the application does not want the text to speech to continue. Note that this call is equivalent to roTextToSpeech.Flush(), and stops speech started using both roAudioGuide.Say() and roTextToSpeech.Say()."
	},
	"ifAudioGuide_Silence": {
		"prefix": "Silence() :: ifAudioGuide",
		"body": "Silence(${1:duration as Integer})",
		"description": "(as Integer) If Audio Guide is enabled, causes text to speech to continue to suppress any application background sound for the amount of time specified by duration (in milliseconds). This can be used to add clarity for longer spoken text that may have pauses that might otherwise allow application background sound to be heard. This method does nothing if Audio Guide is currently disabled."
	},

	//ifAudioMetadata
	"ifAudioMetadata_SetUrl": {
		"prefix": "SetUrl() :: ifAudioMetadata",
		"body": "SetUrl(${1:url as String})",
		"description": "(as Void) Sets the URL to the audio file. Only file URLs are initially supported."
	},
	"ifAudioMetadatad_GetTags": {
		"prefix": "GetTags() :: ifAudioMetadata",
		"body": "GetTags()",
		"description": "(as Object) Returns an associative array that contains a simple set of tags that are common to most audio formats."
	},
	"ifAudioMetadata_GetAudioProperties": {
		"prefix": "GetAudioProperties() :: ifAudioMetadata",
		"body": "GetAudioProperties()",
		"description": "(as Object) Returns an associative array with a simple set of audio properties. These are values which may involve reading a larger portion of the file and thus may take longer to retrieve than the tags."
	},
	"ifAudioMetadata_GetCoverArt": {
		"prefix": "GetCoverArt() :: ifAudioMetadata",
		"body": "GetCoverArt()",
		"description": "(as Object) Returns the cover art if available. Returns an associative array with two entries: \"bytes\" and \"type\". \"bytes\" is an roByteArray containing the image data. \"type\" specifies the mime-type of the image which is almost always either \"image/jpeg\" or \"image/png\".  Looks for the picture designated as the cover art if there is more than one picture in the file. If there is no FrontCover picture then the first picture is used."
	},

	//ifAudioPlayer
	"ifAudioPlayer_SetContentList": {
		"prefix": "SetContentList() :: ifAudioPlayer",
		"body": "SetContentList(${1:contentList as Object})",
		"description": "(as Void) Set the content list to be played by the Audio Player. The caller passes an Array of AssociativeArrays (Content Meta-Data objects) representing the information for each stream to be played. See Content Meta-Data for details on the attributes for each element in the array."
	},
	"ifAudioPlayer_AddContent": {
		"prefix": "AddContent() :: ifAudioMetadata",
		"body": "AddContent(${1:contentItem as Object})",
		"description": "(as Void) Add a new ContentMetaData item to the content list for the Audio Player. The new item is added to the end of the content list."
	},
	"ifAudioPlayer_ClearContent": {
		"prefix": "ClearContent() :: ifAudioMetadata",
		"body": "ClearContent()",
		"description": "(as Void) Clear the content list."
	},
	"ifAudioPlayer_Play": {
		"prefix": "Play() :: ifAudioMetadata",
		"body": "Play()",
		"description": "(as Boolean) Put the Audio Player into play mode starting at the current item in the Content List. This will stop any currently playing content."
	},
	"ifAudioPlayer_Stop": {
		"prefix": "Stop() :: ifAudioMetadata",
		"body": "Stop()",
		"description": "(as Boolean) Stop Audio Player from playing or pausing and cleanup."
	},
	"ifAudioPlayer_Pause": {
		"prefix": "Pause() :: ifAudioMetadata",
		"body": "Pause()",
		"description": "(as Boolean) Put Audio Player into pause mode.  It is an error to Pause if player is not in play mode."
	},
	"ifAudioPlayer_Resume": {
		"prefix": "Resume() :: ifAudioMetadata",
		"body": "Resume()",
		"description": "(as Boolean) Put Audio Player into play mode starting from the pause point.  It is an error to Resume if the player is not in pause mode."
	},
	"ifAudioPlayer_SetLoop": {
		"prefix": "SetLoop() :: ifAudioMetadata",
		"body": "SetLoop(${1:enable as Boolean})",
		"description": "(as Void) Enable/disable the automatic replaying of the Content List.  When enabled, after playing the last item in the content list, the player begins playing the first item.  When disabled, after playing the last item in the content list, the player stops."
	},
	"ifAudioPlayer_SetNext": {
		"prefix": "SetNext() :: ifAudioMetadata",
		"body": "SetNext(${1:item as Integer})",
		"description": "(as Void) Set what the next item to be played within the Content List should be.  item is the zero-based index of the item in the content list.  This item will be played after the currently playing item finishes."
	},
	"ifAudioPlayer_Seek": {
		"prefix": "Seek() :: ifAudioMetadata",
		"body": "Seek(${1:offsetMs as Integer})",
		"description": "(as Boolean) Set the start point of playback for the current item to offsetMs milliseconds. If the item is currently playing, playback will be interrupted and will restart at the specified offset.  If the item is not currently playing, playback will begin at the specified offset when Play() is called."
	},
	"ifAudioPlayer_SetTimeMetaData": {
		"prefix": "SetTimeMetaDataForKeys() :: ifAudioMetadata",
		"body": "SetTimeMetaDataForKeys(${1:keys[] as Dynamic})",
		"description": "(as Void) This method is called to specify the timedMetaData keys that the BrightScript channel is interested in receiving from the timedMetaData event.  If the keys array is empty, all the timed metadata associated with the current stream is sent with the isTimedMetaData event.  If the keys array is invalid, then do not return any keys to the BrightScript channel.  Any keys not specified with this method are deleted by the firmware and never returned to the BrightScript application."
	},

	//ifAudioResource
	"ifAudioResource_Trigger": {
		"prefix": "Trigger() :: ifAudioResource",
		"body": "Trigger(${1:volume as Integer})",
		"description": "(as Void) This method triggers the start of the audio resource sound playback.  The volume is a number between 0 and 100 (percentage of full volume).  50 should be used for normal volume."
	},
	"ifAudioResource_IsPlaying": {
		"prefix": "IsPlaying() :: ifAudioResource",
		"body": "IsPlaying()",
		"description": "(as Boolean) Returns true if this audio resource is currently playing"
	},
	"ifAudioResource_Stop": {
		"prefix": "Stop() :: ifAudioResource",
		"body": "Stop()",
		"description": "(as Void) Stops playing the audio resource.  If the resource is not currently playing, has no effect."
	},
	"ifAudioResource_MaxSimulStreams": {
		"prefix": "MaxSimulStreams() :: ifAudioResource",
		"body": "MaxSimulStreams()",
		"description": "(as Integer) Returns the maximum number of audio resources which can be played simultaneous.  Some Roku models support playing multiple resources and mix the output, others support playing only one stream at a time."
	},
	"ifAudioResource_GetMetaData": {
		"prefix": "GetMetaData() :: ifAudioResource",
		"body": "GetMetaData()",
		"description": "(as Object) Returns an roAssociativeArray array containing the following meta data parameters about the audio resource.  All values are integers."
	},

	//ifByteArray
	"ifByteArray_WriteFile": {
		"prefix": "WriteFile() :: ifByteArray",
		"body": "WriteFile(${1:path as String}${2:, [start_index as Integer]}${3:, [length as Integer]})",
		"description": "(as Boolean) Writes the bytes contained in the Byte Array to the specified file. Returns true if successful."
	},
	"ifByteArray_ReadFile": {
		"prefix": "ReadFile() :: ifByteArray",
		"body": "ReadFile(${1:path as String}${2:, [start_pos as Integer]}${3:, [length as Integer]})",
		"description": "(as Boolean) Reads the specified file into the Byte Array. Any data currently in the Byte Array is discarded. Returns true if successful."
	},
	"ifByteArray_AppendFile": {
		"prefix": "AppendFile() :: ifByteArray",
		"body": "AppendFile(${1:path as String})",
		"description": "(as Boolean) Appends the contents of the Byte Array to the specified file. Returns true if successful."
	},
	"ifByteArray_SetResize": {
		"prefix": "SetResize() :: ifByteArray",
		"body": "SetResize(${1:min_size as Integer}, ${2:auto_resize as Boolean})",
		"description": "(as Void) If the size of the Byte Array is less than min_size, expands the Byte Array to min_size. Also sets the auto-resize attribute of the Byte Array to the specified value."
	},
	"ifByteArray_ToHexString": {
		"prefix": "ToHexString() :: ifByteArray",
		"body": "ToHexString()",
		"description": "(as String) Returns a hexadecimal string representing the contents of the Byte Array, two digits per byte."
	},
	"ifByteArray_FromHexString": {
		"prefix": "FromHexString() :: ifByteArray",
		"body": "FromHexString(${1:hexstring as String})",
		"description": "(as Void) Sets the contents of the Byte Array to the specified value. The string must be an even number of hexadecimal digits. The string must contain valid hexadecimal digits, or the result is undefined. Any data currently in the Byte Array is discarded."
	},
	"ifByteArray_ToBase64String": {
		"prefix": "ToBase64String() :: ifByteArray",
		"body": "ToBase64String()",
		"description": "(as String) Returns a base-64 string representing the contents of the Byte Array."
	},
	"ifByteArray_FromBase64String": {
		"prefix": "FromBase64String() :: ifByteArray",
		"body": "FromBase64String(${1:s as String})",
		"description": "(as Void) Sets the contents of the Byte Array to the specified value. The string must be a valid base-64 encoding. Any data currently in the Byte Array is discarded."
	},
	"ifByteArray_ToAsciiString": {
		"prefix": "ToAsciiString() :: ifByteArray",
		"body": "ToAsciiString()",
		"description": "(as String) Returns the contents of the Byte Array as a string. The contents must be valid UTF-8 (or ASCII subset), or the result is undefined."
	},
	"ifByteArray_FromAsciiString": {
		"prefix": "FromAsciiString() :: ifByteArray",
		"body": "FromAsciiString(${1:s as String})",
		"description": "(as Void) Sets the contents of the Byte Array to the specified string using UTF-8 encoding. Any data currently in the Byte Array is discarded."
	},
	"ifByteArray_GetSignedByte": {
		"prefix": "GetSignedByte() :: ifByteArray",
		"body": "GetSignedByte(${1:index as Integer})",
		"description": "(as Integer) Returns the signed byte at the specified zero-based index in the Byte Array. Use ifArrayGet.GetEntry() or the [ ] array operator to read an unsigned byte in the Byte Array."
	},
	"ifByteArray_GetSignedLong": {
		"prefix": "GetSignedLong() :: ifByteArray",
		"body": "GetSignedLong(${1:index as Integer})",
		"description": "(as Integer) Returns the signed long (four bytes) starting at the specified zero-based index in the Byte Array."
	},
	"ifByteArray_GetCRC32": {
		"prefix": "GetCRC32() :: ifByteArray",
		"body": "GetCRC32()",
		"description": "(as Integer) Calculates a CRC-32 of the contents of the Byte Array."
	},
	"ifByteArray_GetCRC32_2": {
		"prefix": "GetCRC32() :: ifByteArray",
		"body": "GetCRC32(${1:start as Integer}, ${2:length as Integer})",
		"description": "(as Integer) Calculates a CRC-32 of the contents of the Byte Array."
	},
	"ifByteArray_IsLittleEndianCPU": {
		"prefix": "IsLittleEndianCPU() :: ifByteArray",
		"body": "IsLittleEndianCPU()",
		"description": "(as Boolean) Returns true if the CPU architecture is little-endian."
	},

	//ifChannelStore
	"ifChannelStore_GetIdentity": {
		"prefix": "GetIdentity() :: ifChannelStore",
		"body": "GetIdentity()",
		"description": "(as Integer) Returns a unique number for this object that can be used to identify whether a roChannelStoreEvent event originated from this object, by comparing with the roChannelStoreEvent object's GetSourceIdentity() value."
	},
	"ifChannelStore_GetCatalog": {
		"prefix": "GetCatalog() :: ifChannelStore",
		"body": "GetCatalog()",
		"description": "(as Void) Requests the list of In-Channel products which are linked to the running channel. If successful, a later roChannelStoreEvent will be received which contains an roList of roAssociativeArray items."
	},
	"ifChannelStore_GetStoreCatalog": {
		"prefix": "GetStoreCatalog() :: ifChannelStore",
		"body": "GetStoreCatalog()",
		"description": "(as Void) Requests the list of globally available In-Channel products, which are available to all channels. If successful, a later roChannelStoreEvent will be received which contains an roList of roAssociativeArray items."
	},
	"ifChannelStore_GetPurchases": {
		"prefix": "GetPurchases() :: ifChannelStore",
		"body": "GetPurchases()",
		"description": "(as Void) Requests the list of purchases associated with the current user account. If successful, a later roChannelStoreEvent will be received which contains an roList of roAssociativeArray items."
	},
	"ifChannelStore_SetOrder": {
		"prefix": "SetOrder() :: ifChannelStore",
		"body": "SetOrder(${1:order as Object})",
		"description": "(as Void) Sets the current Order (shopping cart) to the elements specified in the parameter, which must be an roList of roAssociativeArray items."
	},
	"ifChannelStore_ClearOrder": {
		"prefix": "ClearOrder() :: ifChannelStore",
		"body": "ClearOrder()",
		"description": "(as Void) Clears the current Order (shopping cart). After this call, the Order is empty."
	},
	"ifChannelStore_DeltaOrder": {
		"prefix": "DeltaOrder() :: ifChannelStore",
		"body": "DeltaOrder(${1:code as Object}, ${2:qty as Integer})",
		"description": "(as Integer) Applies a change in quantity to one item in the current Order (shopping cart). If the item identified by code is not in the Order, it is added with the specified quantity. If the item already exists in the Order, qty is added to the quantity of this item in the Order. qty may be negative. The returned value is the quantity of the item remaining in the Order after applying the change. If this number is zero or negative, the item is deleted from the Order."
	},
	"ifChannelStore_GetOrder": {
		"prefix": "GetOrder() :: ifChannelStore",
		"body": "GetOrder()",
		"description": "(as Object) Retrieves the current Order. The returned object is an roList of roAssociativeArray items."
	},
	"ifChannelStore_DoOrder": {
		"prefix": "DoOrder() :: ifChannelStore",
		"body": "DoOrder()",
		"description": "(as Boolean) Displays the Roku Channel Store Product Purchase Screen populated with information from the current Order. The user can then either approve and complete the purchase, or cancel the purchase. If the user approves the order, this function returns true. Otherwise it returns false. In the case that  the user approves, the channel should wait for and respond to the roChannelStoreEvent.isRequestSucceeded event to get the details of the completed transaction."
	},
	"ifChannelStore_FakeServer": {
		"prefix": "FakeServer() :: ifChannelStore",
		"body": "FakeServer(${1:enable as Boolean})",
		"description": "(as Void) If enable is true, enables a test mode for the roChannelStore component. This test mode short circuits communication to the Roku Channel store. It makes other methods get their responses to async queries and operations from configuration files, rather than actual server communication."
	},
	"ifChannelStore_GetUserData": {
		"prefix": "GetUserData() :: ifChannelStore",
		"body": "GetUserData()",
		"description": "(as Object) The GetUserData() function provides a way to request user authorization to share the user’s account information with the calling channel. The primary use case of this method is to facilitate partner account creation/updating within channels that have a customer billing relationship with Roku. For example, a developer may have a Roku channel that offers a VOD subscription to users. This subscription may require an account with the content provider. The GetUserData() method could be called to read the user’s account information in order to prepopulate an account registration screen."
	},
	"ifChannelStore_GetPartialUserData": {
		"prefix": "GetPartialUserData() :: ifChannelStore",
		"body": "GetPartialUserData(${1:properties as String})",
		"description": "(as Object) This function works like GetUserData(), but allows the caller to specify which user data elements to return. The specified values are also displayed in the user data dialog screen. To tell the function which properties to return, pass a string with a comma separated list of the attribute names. For example, to return only the email address and first name of the user's account, you would call GetPartialUserData(\"email, firstname\")"
	},
	"ifChannelStore_StoreChannelCredData": {
		"prefix": "StoreChannelCredData() :: ifChannelStore",
		"body": "StoreChannelCredData(${1:data as String})",
		"description": "(as Object) This method can be used to store custom data (such as an OAuth token or a custom token) that can be retrieved by calling GetChannelCred. This data is stored securely in the cloud and can be retrieved by other devices linked to the same Roku account. Your channel can use the Roku StoreChannelCredData method to store an authentication artifact with Roku for a signed in user, associating that user with a particular Roku account. For more information, see Universal Authentication Protocol for Single Sign-On."
	},
	"ifChannelStore_GetChannelCred": {
		"prefix": "GetChannelCred() :: ifChannelStore",
		"body": "GetChannelCred()",
		"description": "(as Object) This function can be used to retrieve a Roku Partner Unique Customer Identifier (roku_pucid). The PUCID can be used in place of requiring the user to enter their email address or username again (ex. when setting up a new device on the same Roku account)."
	},
	"ifChannelStore_RequestPartnerOrder": {
		"prefix": "RequestPartnerOrder() :: ifChannelStore",
		"body": "RequestPartnerOrder(${1:orderInfo as roAssociativeArray}, ${2:productID as String})",
		"description": "(as Object) This function checks the user's billing status and is a prerequisite for ConfirmPartnerOrder() when doing transactional purchases"
	},
	"ifChannelStore_ConfirmPartnerOrder": {
		"prefix": "ConfirmPartnerOrder() :: ifChannelStore",
		"body": "ConfirmPartnerOrder(${1:confirmOrderInfo as roAssociativeArray}, ${2:productID as String})",
		"description": "(as Object) This function is equivalent to doOrder() for transactional purchases. The user's billing status must first be confirmed with RequestPartnerOrder() prior to calling this function."
	},

	// ifCompositor
	"ifCompositor_SetDrawTo": {
		"prefix": "SetDrawTo() :: ifCompositor",
		"body": "SetDrawTo(${1:destBitmap as Object}, ${2:rgbaBackground as Integer})",
		"description": "(as Void) Set the destBitmap (roBitmap or roScreen) and the background color."
	},
	"ifCompositor_Draw": {
		"prefix": "Draw() :: ifCompositor",
		"body": "Draw()",
		"description": "(as Void) Draw any dirty sprites (that is, whatever is new or has changed since the last Draw). No compositor or sprite operations will be reflected on the display until Draw() is called. After calling Draw(), you must call Finish() (if single buffered) or SwapBuffers() (if double buffered) before the changes will be user visible."
	},
	"ifCompositor_DrawAll": {
		"prefix": "DrawAll() :: ifCompositor",
		"body": "DrawAll()",
		"description": "(as Void) Redraw all sprites even if not dirty. After calling Draw(), you must call Finish() (if single buffered) or SwapBuffers() (if double buffered) before the changes will be user visible."
	},
	"ifCompositor_NewSprite": {
		"prefix": "NewSprite() :: ifCompositor",
		"body": "NewSprite(${1:x as Integer}, ${2:y as Integer}, ${3:region as Object}, ${4:z as Integer})",
		"description": "(as Object) Returns an roSprite object. Create a new sprite, using an roRegion to define the sprite's bitmap. Position the sprite at coordinate x,y. If z is provided, position the sprite in front of all other sprites with equal or lower z value. Sprites with negative z values are not rendered or displayed on the screen."
	},
	"ifCompositor_NewAnimatedSprite": {
		"prefix": "NewAnimatedSprite() :: ifCompositor",
		"body": "NewAnimatedSprite(${1:x as Integer}, ${2:y as Integer}, ${3:regionArray as Object}, ${4:z as Integer})",
		"description": "(as Object) Returns an roSprite object. Create a new sprite that consists of a sequence of frames to be animated. The frames are defined by the regionArray which is an roArray of roRegions. Position the sprite at coordinate x,y. If z is provided, position the sprite in front of all other sprites with equal or lower z value"
	},
	"ifCompositor_AnimationTick": {
		"prefix": "AnimationTick() :: ifCompositor",
		"body": "AnimationTick(${1:duration as Integer})",
		"description": "(as Void) Duration is the number of ms since the last call. Moves all animated sprites. Sprites will not animate unless you call this function regularly."
	},
	"ifCompositor_ChangeMatchingRegions": {
		"prefix": "ChangeMatchingRegions() :: ifCompositor",
		"body": "ChangeMatchingRegions(${1:oldRegion as Object}, ${2:newRegion as Object})",
		"description": "(as Void) Global search and replace of Sprite roRegions. Replaces regions that match oldRegion with newRegion."
	},

	//ifDateTime
	"ifDateTime_Mark": {
		"prefix": "Mark() :: ifDateTime",
		"body": "Mark()",
		"description": "(as Void) Set the date/time value to the current UTC date and time. Note: roDateTime objects are automatically Marked on creation."
	},
	"ifDateTime_ToLocalTime": {
		"prefix": "ToLocalTime() :: ifDateTime",
		"body": "ToLocalTime()",
		"description": "(as Void) Offsets the date/time value from an assumed UTC date/time to a local date/time using the system time zone setting."
	},
	"ifDateTime_GetTimeZoneOffset": {
		"prefix": "GetTimeZoneOffset() :: ifDateTime",
		"body": "GetTimeZoneOffset()",
		"description": "(as Integer) Returns the offset in minutes from the system time zone to UTC."
	},
	"ifDateTime_AsSeconds": {
		"prefix": "AsSeconds() :: ifDateTime",
		"body": "AsSeconds()",
		"description": "(as Integer) Returns the date/time as the number of seconds from the Unix epoch (00:00:00 1/1/1970 GMT)."
	},
	"ifDateTime_FromSeconds": {
		"prefix": "FromSeconds() :: ifDateTime",
		"body": "FromSeconds(${1:numSeconds as Integer})",
		"description": "(as Void) Set the date/time value using the number of seconds from the Unix epoch."
	},
	"ifDateTime_ToISOString": {
		"prefix": "ToISOString() :: ifDateTime",
		"body": "ToISOString()",
		"description": "(as String) Return an ISO 8601 representation of the date/time value, e.g. \"2015-01-27T13:21:58Z\"."
	},
	"ifDateTime_FromISO8601String": {
		"prefix": "FromISO8601String() :: ifDateTime",
		"body": "FromISO8601String(${1:dateString as String})",
		"description": "(as Void) Set the date/time using a string in the ISO 8601 format. For example \"YYYY-MM-DD HH:MM:SS\" e.g \"2009-01-01 01:00:00.000\" or \"2009-01-01T01:00:00.000\". Note that this function is unaware of the local time zone, so these time formats are effectively UTC even though the ISO 8601 spec says they should be in local time. The above formats are also the only formats recognized by this function, even though the ISO 8601 spec contains other valid formats."
	},
	"ifDateTime_AsDateString": {
		"prefix": "AsDateString() :: ifDateTime",
		"body": "AsDateString(${1|\"long-date\",\"short-weekday\",\"no-weekday\",\"short-month\",\"short-month-short-weekday\",\"short-month-no-weekday\",\"short-date\",\"short-date-dashes\"|})",
		"description": "(as String) Returns the date/time as a formatted string in one of the following formats:\nlong-date | Tuesday October 9, 2012\nshort-weekday | Tue October 9, 2012\nno-weekday | October 9, 2012\nshort-month | Tuesday Oct 9, 2012\nshort-month-short-weekday | Tue Oct 9, 2012\nshort-month-no-weekday | Oct 9, 2012\nshort-date | 10/9/12\nshort-date-dashes | 10-9-12\n"
	},
	"ifDateTime_AsDateStringNoParam": {
		"prefix": "AsDateStringNoParam() :: ifDateTime",
		"body": "AsDateStringNoParam()",
		"description": "(as String) Same as AsDateString(\"long-date\")."
	},
	"ifDateTime_GetWeekday": {
		"prefix": "GetWeekday() :: ifDateTime",
		"body": "GetWeekday()",
		"description": "(as String) Returns the day of the week as a String (e.g. \"Monday\")."
	},
	"ifDateTime_GetYear": {
		"prefix": "GetYear() :: ifDateTime",
		"body": "GetYear()",
		"description": "(as Integer) Returns the date/time value's year as an Integer, e.g. 2015."
	},
	"ifDateTime_GetMonth": {
		"prefix": "GetMonth() :: ifDateTime",
		"body": "GetMonth()",
		"description": "(as Integer) Returns the date/time value's month as an Integer (1=Jan, 12=Dec)."
	},
	"ifDateTime_GetDayOfMonth": {
		"prefix": "GetDayOfMonth() :: ifDateTime",
		"body": "GetDayOfMonth()",
		"description": "(as Integer) Returns the date/time value's day of the month as an Integer (1-31)."
	},
	"ifDateTime_GetHours": {
		"prefix": "GetHours() :: ifDateTime",
		"body": "GetHours()",
		"description": "(as Integer) Returns the date/time value's hour within the day as an Integer (0-23)."
	},
	"ifDateTime_GetMinutes": {
		"prefix": "GetMinutes() :: ifDateTime",
		"body": "GetMinutes()",
		"description": "(as Integer) Returns the date/time value's minute within the hour as an Integer (0-59)."
	},
	"ifDateTime_GetSeconds": {
		"prefix": "GetSeconds() :: ifDateTime",
		"body": "GetSeconds()",
		"description": "(as Integer) Returns the date/time value's second within the minute as an Integer (0-59)."
	},
	"ifDateTime_GetMilliseconds": {
		"prefix": "GetMilliseconds() :: ifDateTime",
		"body": "GetMilliseconds()",
		"description": "(as Integer) Returns the date/time value's millisecond within the second as an Integer (0-999)."
	},
	"ifDateTime_GetLastDayOfMonth": {
		"prefix": "GetLastDayOfMonth() :: ifDateTime",
		"body": "GetLastDayOfMonth()",
		"description": "(as Integer) Returns the date/time value's last day of the month as an Integer (28-31)."
	},
	"ifDateTime_GetDayOfWeek": {
		"prefix": "GetDayOfWeek() :: ifDateTime",
		"body": "GetDayOfWeek()",
		"description": "(as Integer) Returns the date/time value's day of week as an Integer (Sunday=0, Monday=1, ..., Saturday=6)."
	},

	//ifDeviceInfo
	"ifDeviceInfo_GetModel": {
		"prefix": "GetModel() :: ifDeviceInfo",
		"body": "GetModel()",
		"description": "(as String) Returns the model name for the Roku Streaming Player device running the script. This is a five-character alphanumeric string; for example, \"3050X\". Please see Roku Models and Features of the Developer Guide for a list of the current and classic models."
	},
	"ifDeviceInfo_GetModelDisplayName": {
		"prefix": "GetModelDisplayName() :: ifDeviceInfo",
		"body": "GetModelDisplayName()",
		"description": "(as String) Returns the model display name for the Roku Streaming Player device running the script (for example, \"Roku 2 XD\")."
	},
	"ifDeviceInfo_GetModelType": {
		"prefix": "GetModelType() :: ifDeviceInfo",
		"body": "GetModelType()",
		"description": "(as String) Returns a string describing what type of device it is. For future compatibility, the caller should by default assume \"STB\" when anything other than described value is returned. Current possible values are:\n\"STB\" | Set-top box type device.\n\"TV\" | Roku TV type device."
	},
	"ifDeviceInfo_GetModelDetails": {
		"prefix": "GetModelDetails() :: ifDeviceInfo",
		"body": "GetModelDetails()",
		"description": "(as Object) Returns an associative array containing more information about the device model. The following keys are defined:\nVendorName | string describing model vendor\nModelNumber | string describing model number"
	},
	"ifDeviceInfo_GetFriendlyName": {
		"prefix": "GetFriendlyName() :: ifDeviceInfo",
		"body": "GetFriendlyName()",
		"description": "(as String) Returns a string describing the device that may be used for network device selection. The string may be a user-assigned device name or a description of the device such as model name and/or serial number. The string is subject to change and should not be used as a persistent key or ID."
	},
	"ifDeviceInfo_GetVersion": {
		"prefix": "GetVersion() :: ifDeviceInfo",
		"body": "GetVersion()",
		"description": "(as String) Returns the version number of the Roku Streaming Player firmware running on the device. This is a 13 character string; for example \"034.08E01185A\".  The third through sixth characters are the major/minor version number (\"4.08\") and the ninth through twelfth are the build number (\"1185\")."
	},
	"ifDeviceInfo_GetRIDA": {
		"prefix": "GetRIDA() :: ifDeviceInfo",
		"body": "GetRIDA()",
		"description": "(as String) Returns a unique identifier of the unit running the script. The string returned is a Universally Unique Identifier (UUID). This identifier is persistent but can be reset by the user from the device's Settings menu or by performing a factory reset on the device. If the user has set \"Limit ad tracking\" (RIDA is disabled) from the Settings menu, then this identifier should not be used for targeted advertising. Additionally, if the viewer’s country is an EU member country, any data collection must be compliant with the EU General Data Protection Regulation. IsRIDADisabled() should be called to check if the user has disabled RIDA tracking and GetUserCountryCode() should be called to check the user’s country."
	},
	"ifDeviceInfo_IsRIDADisabled": {
		"prefix": "IsRIDADisabled() :: ifDeviceInfo",
		"body": "IsRIDADisabled()",
		"description": "(as Boolean) Returns True if the user has disabled RIDA tracking by selecting \"Limit tracking\" from the Roku Settings menu."
	},
	"ifDeviceInfo_GetPublisherId": {
		"prefix": "GetPublisherId() :: ifDeviceInfo",
		"body": "GetPublisherId()",
		"description": "(as String) "
	},
	"ifDeviceInfo_GetRandomUUID": {
		"prefix": "GetRandomUUID() :: ifDeviceInfo",
		"body": "GetRandomUUID()",
		"description": "(as String) "
	},
	"ifDeviceInfo_GetDisplayType": {
		"prefix": "GetDisplayType() :: ifDeviceInfo",
		"body": "GetDisplayType()",
		"description": "(as String) "
	},
	"ifDeviceInfo_GetDisplayMode": {
		"prefix": "GetDisplayMode() :: ifDeviceInfo",
		"body": "GetDisplayMode()",
		"description": "(as String) "
	},
	"ifDeviceInfo_GetDisplayAspectRation": {
		"prefix": "GetDisplayAspectRation() :: ifDeviceInfo",
		"body": "GetDisplayAspectRation()",
		"description": "(as String) "
	},
	"ifDeviceInfo_GetDisplaySize": {
		"prefix": "GetDisplaySize() :: ifDeviceInfo",
		"body": "GetDisplaySize()",
		"description": "(as Object) "
	},
	"ifDeviceInfo_GetTimeZone": {
		"prefix": "GetTimeZone() :: ifDeviceInfo",
		"body": "GetTimeZone()",
		"description": "(as String) "
	},
	"ifDeviceInfo_HasFeature": {
		"prefix": "HasFeature() :: ifDeviceInfo",
		"body": "HasFeature(${1:feature as String})",
		"description": "(as Boolean) "
	},
	"ifDeviceInfo_GetIPAddrs": {
		"prefix": "GetIPAddrs() :: ifDeviceInfo",
		"body": "GetIPAddrs()",
		"description": "(as Object) "
	},
	"ifDeviceInfo_GetCurrentLocale": {
		"prefix": "GetCurrentLocale() :: ifDeviceInfo",
		"body": "GetCurrentLocale()",
		"description": "(as String) "
	},
	"ifDeviceInfo_GetCountryCode": {
		"prefix": "GetCountryCode() :: ifDeviceInfo",
		"body": "GetCountryCode()",
		"description": "(as String) "
	},
	"ifDeviceInfo_TimeSinceLastKeypress": {
		"prefix": "TimeSinceLastKeypress() :: ifDeviceInfo",
		"body": "TimeSinceLastKeypress()",
		"description": "(as Integer) "
	},
	"ifDeviceInfo_GetVideoMode": {
		"prefix": "GetVideoMode() :: ifDeviceInfo",
		"body": "GetVideoMode()",
		"description": "(as String) "
	},
	"ifDeviceInfo_IsHDMIConnected": {
		"prefix": "IsHDMIConnected() :: ifDeviceInfo",
		"body": "IsHDMIConnected()",
		"description": "(as Boolean) "
	},
	"ifDeviceInfo_GetAudioOutputChannel": {
		"prefix": "GetAudioOutputChannel() :: ifDeviceInfo",
		"body": "GetAudioOutputChannel()",
		"description": "(as String) "
	},
	"ifDeviceInfo_GetLinkStatus": {
		"prefix": "GetLinkStatus() :: ifDeviceInfo",
		"body": "GetLinkStatus()",
		"description": "(as Boolean) "
	},
	"ifDeviceInfo_EnableLinkStatusEvent": {
		"prefix": "EnableLinkStatusEvent() :: ifDeviceInfo",
		"body": "EnableLinkStatusEvent(${1:enable as Boolean})",
		"description": "(as Boolean) "
	},
	"ifDeviceInfo_GetCaptionsMode": {
		"prefix": "GetCaptionsMode() :: ifDeviceInfo",
		"body": "GetCaptionsMode()",
		"description": "(as String) "
	},
	"ifDeviceInfo_GetCaptionsOption": {
		"prefix": "GetCaptionsOption() :: ifDeviceInfo",
		"body": "GetCaptionsOption(${1:option as String})",
		"description": "(as String) "
	},
	"ifDeviceInfo_GetConnectionType": {
		"prefix": "GetConnectionType() :: ifDeviceInfo",
		"body": "GetConnectionType()",
		"description": "(as String) "
	},
	"ifDeviceInfo_GetConnectionInfo": {
		"prefix": "GetConnectionInfo() :: ifDeviceInfo",
		"body": "GetConnectionInfo()",
		"description": "(as Object) "
	},
	"ifDeviceInfo_GetAudioDecodeInfo": {
		"prefix": "GetAudioDecodeInfo() :: ifDeviceInfo",
		"body": "GetAudioDecodeInfo()",
		"description": "(as Object) "
	},
	"ifDeviceInfo_GetVideoDecodeInfo": {
		"prefix": "GetVideoDecodeInfo() :: ifDeviceInfo",
		"body": "GetVideoDecodeInfo()",
		"description": "(as Object) "
	},
}
