{
	// ifAppInfo
	"ifAppInfo_GetID": {
		"prefix": "GetID() :: ifAppInfo",
		"body": "GetID()",
		"description": "(as String) Returns the app's channel ID, e.g. \"12345\" or \"dev\""
	},
	"ifAppInfo_IsDev": {
		"prefix": "IsDev() :: ifAppInfo",
		"body": "IsDev()",
		"description": "(as Boolean) Returns true if the application is side-loaded, i.e. the channel ID is \"dev\""
	},
	"ifAppInfo_GetVersion": {
		"prefix": "GetVersion() :: ifAppInfo",
		"body": "GetVersion()",
		"description": "(as String) Returns the conglomerate version number from the manifest, e.g. \"1.2.3\", as formatted major_version + minor_version + build_version."
	},
	"ifAppInfo_GetTitle": {
		"prefix": "GetTitle() :: ifAppInfo",
		"body": "GetTitle()",
		"description": "(as String) Returns the title value from the manifest."
	},
	"ifAppInfo_GetSubtitle": {
		"prefix": "GetSubtitle() :: ifAppInfo",
		"body": "GetSubtitle()",
		"description": "(as String) Returns the subtitle value from the manifest."
	},
	"ifAppInfo_GetDevID": {
		"prefix": "GetDevID() :: ifAppInfo",
		"body": "GetDevID()",
		"description": "(as String) Returns the app's developer ID, or the keyed developer ID, if the application is side-loaded."
	},
	"ifAppInfo_GetValue": {
		"prefix": "GetValue() :: ifAppInfo",
		"body": "GetValue(${1:key as String})",
		"description": "(as String) Returns the named manifest value, or an empty string if the entry is does not exist."
	},

	//ifAppManager
	"ifAppManager_SetTheme": {
		"prefix": "SetTheme() :: ifAppManager",
		"body": "SetTheme(${1:attributeArray as Object})",
		"description": "(as Void) Set a group of theme attributes for the application. The attributeArray is an roAssociativeArray of attribute/value pairs. The program may create the roAssociativeArray at runtime or read it from an XML file using the roXMLElement object. Existing values for attributes will be overwritten by the values provided. Any values set by a previous SetTheme or SetThemeAttribute call, but not included in the array currently provided by with the subsequent call will remain unchanged.  See roAppManager the list of valid attributes."
	},
	"ifAppManager_SetThemeAttribute": {
		"prefix": "SetThemeAttribute() :: ifAppManager",
		"body": "SetThemeAttribute(${1:attributeName as String}, ${2:attributeValue as String})",
		"description": "(as Void) Set an individual theme attribute for the application. The attributeName is the name of one of the settable theme attributes and the value is the desired setting. This value will override the default value for that attribute or modify the value provided by a previous SetTheme or SetThemeAttribute call to the new value provided. If the attributeName is not valid, no action is performed."
	},
	"ifAppManager_ClearThemeAttribute": {
		"prefix": "ClearThemeAttribute() :: ifAppManager",
		"body": "ClearThemeAttribute(${1:attributeName as String})",
		"description": "(as Void) Clears a previously set attribute and reverts to its default value."
	},
	"ifAppManager_GetUptime": {
		"prefix": "GetUptime() :: ifAppManager",
		"body": "GetUptime()",
		"description": "(as Object) Returns an roTimespan object which is \"marked\" when the user clicked on the application button on the home screen. Calling TotalMilliseconds() on the returned roTimespan object returns the total number of milliseconds since the application started."
	},
	"ifAppManager_GetScreensaverTimeout": {
		"prefix": "GetScreensaverTimeout() :: ifAppManager",
		"body": "GetScreensaverTimeout()",
		"description": "(as Integer) Returns the user's screensaver wait time setting in number of minutes, or zero if the screensaver is disabled."
	},
	"ifAppManager_UpdateLastKeyPressTime": {
		"prefix": "UpdateLastKeyPressTime() :: ifAppManager",
		"body": "UpdateLastKeyPressTime()",
		"description": "(as Void) UpdateLastKeyPressTime can be called to simulate user activity. This resets the idle timer that is used to count down to screensaver activation, so if a screensaver is not already displayed it will reset the timer and defer the activation. This should only be used when the user has specifically initiated a playback mode in your app, in which case you can call UpdateLastKeyPressTime periodically, such as when advancing the slideshow image."
	},
	"ifAppManager_SetUserSignedIn": {
		"prefix": "SetUserSignedIn() :: ifAppManager",
		"body": "SetUserSignedIn(${1:signedIn as Boolean})",
		"description": "(as Void) This method allows a channel to tell Roku when the user is signed in or signed out of the channel. If the channel is removed, then the firmware will call SetUserSignedIn(false) on the channel's behalf. This method accepts the signedIn parameter, which if set to true indicates the user is signed in, and if set to false, indicates the user is signed out."
	},
	"ifAppManager_SetAutomaticAudioGuideEnabled": {
		"prefix": "SetAutomaticAudioGuideEnabled() :: ifAppManager",
		"body": "SetAutomaticAudioGuideEnabled(${1:enabled as Boolean})",
		"description": "(as Void) Enables or disables automatic Audio Guide and override any manifest setting. This is useful for channels that want to temporarily turn off automatic Audio Guide for specific screens."
	},
	"ifAppManager_IsAppInstalled": {
		"prefix": "IsAppInstalled() :: ifAppManager",
		"body": "IsAppInstalled(${1:channelID as String}, ${2:version as String})",
		"description": "(as Boolean) This method returns true if a channel with the specified channelID and the minimum version required is installed. Version field could be an empty string to avoid a version check. This is useful for developers who want to cross-promote their apps. For example, if a developer writes a game A and an app B, in game A they would want to know if the user has app B installed so they know whether to advertise app B in game A to promote the app. If it is already installed, the developer would not need to advertise app B."
	},

	//ifArray
	"ifArray_Peek": {
		"prefix": "Peek() :: ifArray",
		"body": "Peek()",
		"description": "(as Dynamic) Returns the last (highest index) array entry without removing it.  If the array is empty, returns invalid."
	},
	"ifArray_Pop": {
		"prefix": "Pop() :: ifArray",
		"body": "Pop()",
		"description": "(as Dynamic) Returns the last (highest index) array entry and removes it from the array.  If the array is empty, returns invalid and does not change the array."
	},
	"ifArray_Push": {
		"prefix": "Push() :: ifArray",
		"body": "Push(${1:tvalue as Dynamic})",
		"description": "(as Void) Adds tvalue as the new highest index entry in the array (adds to the end of the array)."
	},
	"ifArray_Shift": {
		"prefix": "Shift() :: ifArray",
		"body": "Shift()",
		"description": "(as Dynamic) Removes the index zero entry from the array and shifts every other entry down one to fill the hole. Returns the removed entry. This is like a Pop from the start of the array instead of the end."
	},
	"ifArray_Unshift": {
		"prefix": "Unshift() :: ifArray",
		"body": "Unshift(${1:tvalue as Dynamic})",
		"description": "(as Void) Adds a new index zero to the array and shifts every other entry up one to accommodate. This is like a Push to the start of the array instead of the end."
	},
	"ifArray_Delete": {
		"prefix": "Delete() :: ifArray",
		"body": "Delete(${1:index as Integer})",
		"description": "(as Boolean) Deletes the indicated array entry, and shifts down all entries above to fill the hole. The array length is decreased by one.  If the entry was successfully deleted, returns true.  If index is out of range, returns false and does not change the array."
	},
	"ifArray_Count": {
		"prefix": "Count() :: ifArray",
		"body": "Count()",
		"description": "(as Integer) Returns the length of the array; that is, one more than the index of highest entry."
	},
	"ifArray_Clear": {
		"prefix": "Clear() :: ifArray",
		"body": "Clear()",
		"description": "(as Void) Deletes every entry in the array."
	},
	"ifArray_Append": {
		"prefix": "Append() :: ifArray",
		"body": "Append(${1:array as Object})",
		"description": "(as Void) Appends each entry of one roArray to another. If the passed Array contains \"holes\" (entries that were never set to a value), they are not appended."
	},

	//ifArrayGet
	"ifArrayGet_GetEntry": {
		"prefix": "GetEntry() :: ifArrayGet",
		"body": "GetEntry(${1:index as Integer})",
		"description": "(as Dynamic) Returns an Array entry of a given index. Entries start at zero. If an entry is fetched that has not been set, \"invalid\" is returned."
	},

	//ifArrayJoin
	"ifArrayJoin_Join": {
		"prefix": "Join() :: ifArrayJoin",
		"body": "Join(${1:separator as String})",
		"description": "(as String) Creates a string by joining all array elements together separated by the specified separator. All elements must be of type string, otherwise an empty string is returned."
	},

	//ifArraySet
	"ifArraySet_SetEntry": {
		"prefix": "SetEntry() :: ifArraySet",
		"body": "SetEntry(${1:index as Integer}, ${2:tvalue as Dynamic})",
		"description": "(as Void) Sets an entry at a given index to the passed value.  If index is beyond the bounds of the array, the array is expanded to accommodate it."
	},

	//ifArraySort
	"ifArraySort_Sort": {
		"prefix": "Sort() :: ifArraySort",
		"body": "Sort(${1:flags as String = \"\"})",
		"description": "(as Void) Performs a stable sort. Items are arbitrarily grouped by comparable type of number or string, and are sorted within the group with a logical comparison. If \"r\" is included in flags, a reverse sort is performed. If \"i\" is included in flags, a case-insensitive sort is performed. If invalid flags are specified, the sort is not performed."
	},
	"ifArraySort_SortBy": {
		"prefix": "SortBy() :: ifArraySort",
		"body": "SortBy(${1:fieldName as String}, ${2:flags as String = \"\"})",
		"description": "(as Void) Performs a stable sort of an array of associative arrays by value of a common field. Items are arbitrarily grouped by comparable value type of number or string, and are sorted within the group with a logical comparison. If \"r\" is included in flags, a reverse sort is performed. If \"i\" is included in flags, a case-insensitive sort is performed. If invalid flags are specified, the sort is not performed."
	},
	"ifArraySort_Reverse": {
		"prefix": "Reverse() :: ifArraySort",
		"body": "Reverse()",
		"description": "(as Void) Reverses the order of elements in an array."
	}
}
